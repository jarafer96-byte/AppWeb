<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Step 0 - Optimizar imÃ¡genes</title>
  <style>
    body { background:#000; color:#fff; font-family:'Raleway',sans-serif; padding:40px; }
    h2 { text-align:center; margin-bottom:6px; }
    .hint { text-align:center; color:#ccc; margin-bottom:20px; }

    form { text-align:center; margin-bottom:20px; }
    .file-block { text-align:center; }
    input[type="file"] { margin-bottom:10px; color:white; }
    .file-count { color:#ccc; font-size:0.9em; margin-top:6px; min-height:20px; }

    button { background:linear-gradient(135deg,#ff0080,#7928ca); border:none; color:white;
             padding:10px 20px; border-radius:6px; cursor:pointer; font-weight:bold; }
    button:hover { opacity:0.9; }

    .error { color:#ff4d4d; margin-top:10px; text-align:center; min-height:22px; }
    .meta { text-align:center; color:#ccc; font-size:0.9em; margin-top:8px; min-height:20px; }

    .botonera { display:flex; justify-content:center; gap:20px; flex-wrap:wrap; margin-top:20px; }
    .botonera .col { text-align:center; min-width:200px; }
    .botonera p { color:white; font-weight:bold; margin-bottom:6px; }

    .preview { display:flex; flex-wrap:wrap; gap:12px; justify-content:center; margin-top:20px; }
    .preview-item { position:relative; width:180px; }
    .preview img { width:100%; height:auto; border:1px solid #333; border-radius:6px; object-fit:contain; background:#111; }

    .badge { position:absolute; bottom:6px; left:6px; background:rgba(0,0,0,0.6); color:#fff; font-size:11px;
             padding:3px 6px; border-radius:4px; max-width:90%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    .remove-btn { position:absolute; top:4px; right:4px; background:rgba(255,0,0,0.8); color:white; border:none;
                  border-radius:50%; width:22px; height:22px; cursor:pointer; font-size:14px; line-height:2px; text-align:center; padding-left:10px; }

    .btn-disabled { opacity:0.5; cursor:not-allowed; }
  </style>
</head>
<body>
  <h2>Optimiza y sube tus imÃ¡genes</h2>
  <p class="hint">MÃ¡x. 500 imÃ¡genes, convertidas automÃ¡ticamente a WebP (300Ã—180 px, calidad 80, max: 3mb por foto)</p>

<div class="file-block">
  <input type="file" name="imagenes" id="imagenes" multiple accept="image/*">
  <div id="fileCount" class="file-count"></div>
</div>

<div class="botonera">
  <div class="col">
    <p>Paso 1</p>
    <button type="button" id="optimizeBtn">Optimizar</button>
  </div>
  <div class="col">
    <p>Opcional</p>
    <button type="button" id="clearBtn">Quitar todas</button>
  </div>
  <div class="col">
    <p>Opcional</p>
    <button type="button" id="downloadAllBtn" class="btn-disabled" disabled>Descargar optimizadas</button>
  </div>
  <div class="col">
    <p>Paso 2</p>
    <button type="button" id="uploadBtn" class="btn-disabled" disabled>Subir optimizadas</button>
  </div>
  <div class="col">
    <p>Finalizar</p>
    <button type="button" id="continueBtn" class="btn-disabled" disabled>Continuar</button>
  </div>
</div>
</form>


  <div class="error" id="error"></div>
  <div class="meta" id="meta"></div>
  <div class="preview" id="preview"></div>

  <!-- Paginador y selector -->
  <div id="pager" style="display:flex; justify-content:center; gap:8px; margin-top:12px;"></div>
  <div style="text-align:center; margin-top:8px;">
    <label style="color:#ccc; font-size:0.9em;">Miniaturas por pÃ¡gina:</label>
    <select id="pageSizeSelect">
      <option value="20" selected>20</option>
      <option value="30">30</option>
      <option value="50">50</option>
    </select>
  </div>

  <script>
    const input = document.getElementById('imagenes');
    const errorEl = document.getElementById('error');
    const metaEl = document.getElementById('meta');
    const previewEl = document.getElementById('preview');
    const fileCountEl = document.getElementById('fileCount');

    const clearBtn = document.getElementById('clearBtn');
    const optimizeBtn = document.getElementById('optimizeBtn');
    const downloadAllBtn = document.getElementById('downloadAllBtn');
    const uploadBtn = document.getElementById('uploadBtn');

    let originales = [];
    let optimizadas = [];
    let pageSize = parseInt(localStorage.getItem("pageSize") || "20", 10);
    let pageOrig = 1;
    let pageOpt = 1;
    // Array global para guardar los blobs optimizados
    let blobsOptimized = [];

    // Selector de tamaÃ±o de pÃ¡gina
    const pageSizeSelect = document.getElementById('pageSizeSelect');
    if (pageSizeSelect) {
      pageSizeSelect.value = String(pageSize);
      pageSizeSelect.addEventListener('change', () => {
        pageSize = parseInt(pageSizeSelect.value, 10);
        localStorage.setItem("pageSize", String(pageSize));
        pageOrig = 1; pageOpt = 1;
        renderOriginales();
        renderOptimizadas();
      });
    }
    function showError(msg) {
  errorEl.textContent = msg;
  errorEl.style.color = '#ff4d4d'; // rojo
}
    
function showInfo(msg) {
  metaEl.textContent = msg;
  metaEl.style.color = '#0f0'; // verde
}

function resetFeedback() {
  errorEl.textContent = '';
  metaEl.textContent = '';
}

    // Paginador
    function renderPager(totalItems, currentPage, onGoToPage) {
      const pagerEl = document.getElementById('pager');
      pagerEl.innerHTML = '';
      const totalPages = Math.max(1, Math.ceil(totalItems / pageSize));

      const prev = document.createElement('button');
      prev.textContent = 'Â«';
      prev.disabled = currentPage <= 1;
      prev.onclick = () => onGoToPage(currentPage - 1);
      pagerEl.appendChild(prev);

      const maxButtons = 10;
      let start = Math.max(1, currentPage - Math.floor(maxButtons/2));
      let end = Math.min(totalPages, start + maxButtons - 1);
      if (end - start + 1 < maxButtons) start = Math.max(1, end - maxButtons + 1);

      for (let p = start; p <= end; p++) {
        const btn = document.createElement('button');
        btn.textContent = String(p);
        btn.style.minWidth = '32px';
        if (p === currentPage) {
          btn.disabled = true;
          btn.classList.add('btn-disabled');
        } else {
          btn.onclick = () => onGoToPage(p);
        }
        pagerEl.appendChild(btn);
      }

      const next = document.createElement('button');
      next.textContent = 'Â»';
      next.disabled = currentPage >= totalPages;
      next.onclick = () => onGoToPage(currentPage + 1);
      pagerEl.appendChild(next);
    }

    // Guardar lista de originales en localStorage (metadatos)
    function saveOriginalesToLocal() {
      const data = originales.map(f => ({
        name: f.name,
        size: f.size,
        lastModified: f.lastModified
      }));
      localStorage.setItem("imagenesOriginales", JSON.stringify(data));
    }

    // IndexedDB helper: asegura store y se auto-repara si falta
    function ensureDB(callback) {
      const request = indexedDB.open("imagenesDB", 2);
      request.onupgradeneeded = e => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains("imagenes")) {
          db.createObjectStore("imagenes");
          console.log("ðŸ“¦ Store 'imagenes' creado.");
        }
      };
      request.onsuccess = e => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains("imagenes")) {
          console.warn("âš ï¸ DB sin store. Se borra y recrea.");
          db.close();
          const del = indexedDB.deleteDatabase("imagenesDB");
          del.onsuccess = () => {
            const re = indexedDB.open("imagenesDB", 2);
            re.onupgradeneeded = ev => ev.target.result.createObjectStore("imagenes");
            re.onsuccess = ev => callback(ev.target.result);
          };
          del.onerror = () => {
            console.error("âŒ No se pudo borrar la DB.");
            callback(db);
          };
        } else {
          callback(db);
        }
      };
      request.onerror = e => console.error("âŒ Error abriendo IndexedDB:", e.target.error);
    }

    function guardarImagenEnIndexedDB(file) {
      ensureDB(db => {
        const tx = db.transaction("imagenes", "readwrite");
        tx.objectStore("imagenes").put(file, file.name);
        tx.oncomplete = () => {
          let lista = JSON.parse(localStorage.getItem("imagenesLista") || "[]");
          if (!lista.includes(file.name)) {
            lista.push(file.name);
            localStorage.setItem("imagenesLista", JSON.stringify(lista));
          }
        };
        tx.onerror = e => console.error("âŒ Error guardando imagen en IndexedDB:", e.target.error);
      });
    }

    // Restaurar al cargar desde IndexedDB usando la lista de nombres
    window.addEventListener("DOMContentLoaded", () => {
      const lista = JSON.parse(localStorage.getItem("imagenesLista") || "[]");
      if (!lista.length) return;
      ensureDB(db => {
        const tx = db.transaction("imagenes", "readonly");
        const store = tx.objectStore("imagenes");
        const recs = [];
        let pending = lista.length;
        lista.forEach(name => {
          const req = store.get(name);
          req.onsuccess = e => {
            const fileOrBlob = e.target.result;
            if (fileOrBlob) {
              const f = fileOrBlob instanceof File
                ? fileOrBlob
                : new File([fileOrBlob], name, { type: fileOrBlob.type || "image/*" });
              recs.push(f);
            }
            if (--pending === 0) {
              originales = recs;
              syncInputWithOriginales();
              renderOriginales();
              actualizarMeta();
            }
          };
          req.onerror = () => {
            console.error("âŒ Error leyendo", name, "de IndexedDB");
            if (--pending === 0) {
              originales = recs;
              syncInputWithOriginales();
              renderOriginales();
              actualizarMeta();
            }
          };
        });
      });
    });
    
    function bytesToKB(b) { return (b / 1024).toFixed(1); }
    function bytesToMB(b) { return (b / (1024*1024)).toFixed(2); }

    // Sincroniza input.files con originales usando DataTransfer para que el selector muestre â€œN archivosâ€
    function syncInputWithOriginales() {
      const dt = new DataTransfer();
      originales.forEach(file => dt.items.add(file));
      input.files = dt.files;
      actualizarFileCount();
    }

    function actualizarFileCount() {
      if (originales.length) {
        const totalBytes = originales.reduce((s,f)=>s+f.size,0);
        fileCountEl.textContent = `${originales.length} archivo(s) â€” ${bytesToMB(totalBytes)} MB`;
      } else {
        fileCountEl.textContent = '';
      }
    }

    // Input change: validaciones + guardado + feedback
input.addEventListener('change', () => {
  resetFeedback(); // â† reemplaza resetErrores()
  const nuevos = Array.from(input.files);
  let duplicados = 0;

  // ValidaciÃ³n cantidad
  if (originales.length + nuevos.length > 500) {
    showError('âš ï¸ MÃ¡ximo 500 imÃ¡genes permitidas.');
    input.value = '';
    return;
  }

  // ValidaciÃ³n tamaÃ±o
  for (const f of nuevos) {
    if (f.size > 3 * 1024 * 1024) {
      showError(`âš ï¸ La imagen "${f.name}" supera 3 MB.`);
      input.value = '';
      return;
    }
  }

  // Evitar duplicados
  nuevos.forEach(f => {
    const existe = originales.some(a =>
      a.name === f.name && a.size === f.size && a.lastModified === f.lastModified
    );
    if (!existe) {
      originales.push(f);
      guardarImagenEnIndexedDB(f);
    } else {
      duplicados++;
    }
  });

  // Feedback visual
  if (duplicados > 0) {
    showError(`âš ï¸ ${duplicados} imagen(es) duplicada(s) fueron ignoradas.`);
  } else if (nuevos.length > 0) {
    showInfo(`âœ… ${nuevos.length} imagen(es) agregadas correctamente.`);
  }

  saveOriginalesToLocal();
  syncInputWithOriginales();
  renderOriginales();
  actualizarMeta();
});


    // Quitar todas
    clearBtn.addEventListener('click', () => {
      // Revocar URLs de optimizadas para evitar fugas
      optimizadas.forEach(i => i.url && URL.revokeObjectURL(i.url));
      optimizadas = [];
      originales = [];
      previewEl.innerHTML = '';
      actualizarMeta();

      downloadAllBtn.disabled = true; downloadAllBtn.classList.add('btn-disabled');
      uploadBtn.disabled = true; uploadBtn.classList.add('btn-disabled');

      syncInputWithOriginales();
      input.value = '';
      actualizarFileCount();

      // Limpiar cache local
      localStorage.removeItem("imagenesLista");
      localStorage.removeItem("imagenesOriginales");
      const del = indexedDB.deleteDatabase("imagenesDB");
      del.onsuccess = () => console.log("ðŸ—‘ï¸ IndexedDB borrada al limpiar todas");
    });

    function actualizarMeta() {
  const totalOrig = originales.reduce((sum, f) => sum + f.size, 0);
  const totalOpt  = optimizadas.reduce((sum, f) => sum + f.size, 0);
  const partes = [];

  if (originales.length) {
    partes.push(`${originales.length} original(es) â€” ${bytesToKB(totalOrig)} KB`);
  }
  if (optimizadas.length) {
    partes.push(`${optimizadas.length} optimizada(s) â€” ${bytesToKB(totalOpt)} KB`);
  }

  metaEl.textContent = partes.join(' | ');

  const hasOpt = optimizadas.length > 0;
  downloadAllBtn.disabled = !hasOpt;
  uploadBtn.disabled = !hasOpt;
  downloadAllBtn.classList.toggle('btn-disabled', !hasOpt);
  uploadBtn.classList.toggle('btn-disabled', !hasOpt);
}


    // Render originales con paginaciÃ³n + lazy loading + feedback
function renderOriginales() {
  previewEl.innerHTML = '';

  const total = originales.length;
  const totalPages = Math.max(1, Math.ceil(total / pageSize));
  pageOrig = Math.min(pageOrig, totalPages);

  const start = (pageOrig - 1) * pageSize;
  const end = Math.min(start + pageSize, total);
  const pageItems = originales.slice(start, end);

  pageItems.forEach((file, idxPage) => {
    const reader = new FileReader();
    reader.onload = e => {
      const item = document.createElement('div');
      item.className = 'preview-item';

      const img = document.createElement('img');
      img.src = e.target.result;
      img.loading = 'lazy';
      img.decoding = 'async';
      img.alt = file.name;

      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-btn';
      removeBtn.textContent = 'âœ–';
      removeBtn.setAttribute('aria-label', 'Eliminar imagen');
      removeBtn.onclick = () => {
        originales.splice(start + idxPage, 1);
        saveOriginalesToLocal();
        syncInputWithOriginales();
        renderOriginales();
        actualizarMeta();
        showInfo(`â„¹ï¸ Imagen "${file.name}" eliminada de originales.`);
      };

      const badge = document.createElement('div');
      badge.className = 'badge';
      badge.textContent = `${file.name} â€” ${bytesToKB(file.size)} KB`;

      item.appendChild(img);
      item.appendChild(removeBtn);
      item.appendChild(badge);
      previewEl.appendChild(item);
    };
    reader.readAsDataURL(file);
  });

  renderPager(total, pageOrig, (p) => {
    pageOrig = p;
    renderOriginales();
  });

  // Feedback de pÃ¡gina actual
  if (total > 0) {
    showInfo(`ðŸ“„ PÃ¡gina ${pageOrig} de ${totalPages} â€” mostrando ${pageItems.length} de ${total} originales.`);
  } else {
    showError("âš ï¸ No hay imÃ¡genes originales para mostrar.");
  }
}


    // Resize a WebP 300x180 q=0.8
    async function resizeToWebP(file) {
      const imgUrl = URL.createObjectURL(file);
      const img = await new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => resolve(image);
        image.onerror = reject;
        image.src = imgUrl;
      });

      const targetW = 300, targetH = 180;
      const canvas = document.createElement('canvas');
      canvas.width = targetW; canvas.height = targetH;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, targetW, targetH);

      const ratio = Math.min(targetW / img.width, targetH / img.height);
      const newW = Math.round(img.width * ratio);
      const newH = Math.round(img.height * ratio);
      const offsetX = Math.floor((targetW - newW) / 2);
      const offsetY = Math.floor((targetH - newH) / 2);

      ctx.drawImage(img, offsetX, offsetY, newW, newH);
      URL.revokeObjectURL(imgUrl);

      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/webp', 0.8));
      return blob;
    }

// Render optimizadas con paginaciÃ³n + lazy loading + feedback
function renderOptimizadas() {
  previewEl.innerHTML = '';

  const total = optimizadas.length;
  const totalPages = Math.max(1, Math.ceil(total / pageSize));
  pageOpt = Math.min(pageOpt, totalPages);

  // Feedback si no hay optimizadas
  if (total === 0) {
    showError("âš ï¸ No hay imÃ¡genes optimizadas para mostrar.");
    actualizarMeta();
    return;
  }

  const start = (pageOpt - 1) * pageSize;
  const end = Math.min(start + pageSize, total);
  const pageItems = optimizadas.slice(start, end);

  pageItems.forEach((item, idxPage) => {
    const wrap = document.createElement('div');
    wrap.className = 'preview-item';

    const img = document.createElement('img');
    img.src = item.url;
    img.loading = 'lazy';
    img.decoding = 'async';
    img.alt = item.name;

    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-btn';
    removeBtn.textContent = 'âœ–';
    removeBtn.setAttribute('aria-label', 'Eliminar imagen');
    removeBtn.onclick = () => {
      URL.revokeObjectURL(item.url);
      optimizadas.splice(start + idxPage, 1);
      renderOptimizadas();
      actualizarMeta();
      showInfo(`â„¹ï¸ Imagen "${item.name}" eliminada de optimizadas.`);
    };

    const badge = document.createElement('div');
    badge.className = 'badge';
    badge.textContent = `${item.name} â€” ${bytesToKB(item.size)} KB`;

    wrap.appendChild(img);
    wrap.appendChild(removeBtn);
    wrap.appendChild(badge);
    previewEl.appendChild(wrap);
  });

  renderPager(total, pageOpt, (p) => {
    pageOpt = p;
    renderOptimizadas();
  });

  // Feedback de pÃ¡gina actual
  showInfo(`ðŸ“„ PÃ¡gina ${pageOpt} de ${totalPages} â€” mostrando ${pageItems.length} de ${total} optimizadas.`);
}

// Descargar todas optimizadas (ZIP) con feedback
downloadAllBtn.addEventListener('click', async () => {
  if (!optimizadas.length) {
    showError("âš ï¸ No hay imÃ¡genes optimizadas para descargar.");
    return;
  }

  // Spinner visual en el botÃ³n
  downloadAllBtn.disabled = true;
  downloadAllBtn.textContent = "Generando ZIP...";

  try {
    const zip = new JSZip();
    for (const item of optimizadas) {
      const arrayBuffer = await item.blob.arrayBuffer();
      zip.file(item.name, arrayBuffer);
    }
    const content = await zip.generateAsync({ type: "blob" });
    saveAs(content, "imagenes_optimizadas.zip");

    showInfo(`âœ… ${optimizadas.length} imagen(es) descargadas en ZIP.`);
  } catch (err) {
    showError("âŒ Error al generar el ZIP de imÃ¡genes.");
    console.error(err);
  }

  // Restaurar botÃ³n
  downloadAllBtn.disabled = false;
  downloadAllBtn.textContent = "Descargar optimizadas";
});

// Optimizar en tandas de 50 imÃ¡genes
async function optimizeInBatches(batchSize = 50) {
  resetFeedback();
  if (!originales.length) {
    showError('âš ï¸ SubÃ­ imÃ¡genes primero.');
    return;
  }

  // Spinner visual
  optimizeBtn.disabled = true;
  optimizeBtn.textContent = 'Optimizando...';

  // liberar URLs previas
  optimizadas.forEach(i => i.url && URL.revokeObjectURL(i.url));
  optimizadas = [];

  let okCount = 0, failCount = 0;

  for (let i = 0; i < originales.length; i += batchSize) {
    const batch = originales.slice(i, i + batchSize);

    for (const file of batch) {
      try {
        const blob = await resizeToWebP(file);
        const nameBase = file.name.replace(/\.(png|jpg|jpeg|gif|tiff|bmp|webp)$/i, '');
        const finalName = `${nameBase}.webp`;
        optimizadas.push({ name: finalName, blob, size: blob.size, url: URL.createObjectURL(blob) });
        okCount++;
      } catch {
        failCount++;
      }
    }

    // Render parcial para feedback
    pageOpt = 1;
    renderOptimizadas();
    actualizarMeta();

    // Pausa breve para liberar el hilo y refrescar la UI
    await new Promise(r => setTimeout(r, 100));
  }

  // Restaurar botÃ³n
  optimizeBtn.disabled = false;
  optimizeBtn.textContent = 'Optimizar';

  // Feedback visual
  if (failCount > 0) {
    showError(`âš ï¸ ${failCount} imagen(es) no pudieron optimizarse.`);
  }
  if (okCount > 0) {
    showInfo(`âœ… ${okCount} imagen(es) optimizadas correctamente.`);
  }
}

// Listener del botÃ³n
optimizeBtn.addEventListener('click', () => optimizeInBatches(50));


async function enviarOptimizado(batchSize = 50) {
  console.log("ðŸš€ [FRONT] Iniciando envÃ­o de optimizadas...");

  const uploadBtn = document.getElementById("uploadBtn");
  uploadBtn.disabled = true;
  uploadBtn.textContent = "Subiendo...";

  let okCount = 0;
  let failCount = 0;

  // blobsOptimized es tu array global con las imÃ¡genes optimizadas
  console.log(`ðŸ“¦ [FRONT] Total blobs optimizados: ${blobsOptimized.length}`);

  for (let i = 0; i < blobsOptimized.length; i += batchSize) {
    const batch = blobsOptimized.slice(i, i + batchSize);
    console.log(`âž¡ï¸ [FRONT] Procesando batch ${i / batchSize + 1}: ${batch.length} imÃ¡genes`);

    const formData = new FormData();
    batch.forEach((blob, idx) => {
      const filename = `opt_${i + idx}.webp`;
      formData.append("imagenes", blob, filename);
      console.log(`ðŸ“ [FRONT] AÃ±adida al FormData: ${filename}, tamaÃ±o: ${blob.size} bytes`);
    });

    try {
      const resp = await fetch("/upload-image", {
        method: "POST",
        body: formData
      });

      console.log(`ðŸ”— [FRONT] POST /upload-image â†’ status: ${resp.status}`);

      if (!resp.ok) {
        failCount += batch.length;
        console.error(`âŒ [FRONT] Error HTTP ${resp.status} en batch ${i / batchSize + 1}`);
        continue;
      }

      const data = await resp.json();
      console.log("ðŸ“¥ [FRONT] Respuesta JSON:", data);

      if (data.ok) {
        okCount += data.imagenes.length;
        data.imagenes.forEach(url => {
          console.log(`âœ… [FRONT] Subida completa: ${url}`);
        });
      } else {
        failCount += batch.length;
        console.error(`âŒ [FRONT] Backend devolviÃ³ error: ${data.error}`);
      }
    } catch (err) {
      failCount += batch.length;
      console.error(`ðŸ’¥ [FRONT] ExcepciÃ³n en fetch:`, err);
    }
  }

  console.log(`ðŸ“Š [FRONT] Resumen â†’ OK: ${okCount}, FAIL: ${failCount}`);

  uploadBtn.disabled = false;
  uploadBtn.textContent = "Subir optimizadas";

  // Feedback visual
  const feedback = document.getElementById("feedback");
  feedback.textContent = `âœ… ${okCount} imÃ¡genes subidas, âš ï¸ ${failCount} fallidas`;

  // Si querÃ©s redirigir automÃ¡ticamente:
  if (okCount > 0) {
    const continueBtn = document.getElementById("continueBtn");
    continueBtn.disabled = false;
    continueBtn.classList.remove("btn-disabled");
    console.log("âž¡ï¸ [FRONT] BotÃ³n 'Continuar' habilitado");
  }

  return okCount > 0;
}

document.getElementById("uploadBtn").addEventListener("click", () => enviarOptimizado(50));
document.getElementById("uploadBtn").addEventListener("click", async () => {
  const ok = await enviarOptimizado(50);
  if (ok) {
    // habilitar botÃ³n continuar
    const continueBtn = document.getElementById("continueBtn");
    continueBtn.disabled = false;
    continueBtn.classList.remove("btn-disabled");
  }
});

document.getElementById("continueBtn").addEventListener("click", () => {
  // redirigir al siguiente paso
  window.location.href = "/step2"; // o "/preview" segÃºn tu flujo
});
</script>
<!-- LibrerÃ­as para ZIP y descarga -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
</body>
</html>
