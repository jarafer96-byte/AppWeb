
from flask import Flask, render_template, request, redirect, session, send_file, url_for, jsonify, current_app
import os
import uuid
import time
import json
import requests
import traceback
from werkzeug.utils import secure_filename
from zipfile import ZipFile
from io import BytesIO
from PIL import Image
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
import shortuuid
import mercadopago
import base64
from google.cloud import firestore

token = os.getenv("GITHUB_TOKEN")
GITHUB_USERNAME = "jarafer96-byte"        # tu usuario de GitHub

app = Flask(__name__)
app.config['MAX_CONTENT_LENGTH'] = 4 * 1024 * 1024  # 4 MB
app.secret_key = os.getenv("FLASK_SECRET_KEY") or "clave-secreta-temporal"
app.config['SESSION_COOKIE_SECURE'] = not app.debug  # True en producci√≥n, False en local


@app.errorhandler(413)
def too_large(e):
    return "Archivo demasiado grande (m√°x. 4 MB)", 413

# üî• Configuraci√≥n de Firestore 
FIREBASE_PROJECT_ID = "appweb-2167a" 
FIREBASE_API_KEY = "AIzaSyALJLWb4tPUVq9UwZ9dB-L6P1AJX9TWCeM" 
FIREBASE_COLLECTION = "productos"

# ‚úÖ Actualizaci√≥n en subir_a_firestore
def subir_a_firestore(producto):
    grupo_original = producto["grupo"].strip()
    subgrupo_original = producto.get("subgrupo", "general").strip()
    nombre_original = producto["nombre"].strip()

    # Normalizaci√≥n solo para el ID
    grupo_id = grupo_original.replace(" ", "_").lower()
    nombre_id = nombre_original.replace(" ", "_").lower()
    fecha = time.strftime("%Y%m%d")
    custom_id = f"{nombre_id}_{fecha}_{grupo_id}"

    # URL con ID personalizado
    doc_path = f"projects/{FIREBASE_PROJECT_ID}/databases/(default)/documents/{FIREBASE_COLLECTION}/{custom_id}"
    url = f"https://firestore.googleapis.com/v1/{doc_path}?key={FIREBASE_API_KEY}"
    headers = {"Content-Type": "application/json"}

    try:
        precio = int(producto["precio"].replace("$", "").replace(".", "").strip())
        orden = int(producto.get("orden", 999))
    except ValueError:
        print(f"‚ùå Precio u orden inv√°lido en producto: {producto['nombre']}")
        return False

    data = {
      "name": doc_path,
      "fields": {
        "nombre": {"stringValue": nombre_original},
        "id_base": {"stringValue": f"{nombre_id}_{fecha}_{grupo_id}"},
        "precio": {"integerValue": precio},
        "grupo": {"stringValue": grupo_original},
        "subgrupo": {"stringValue": subgrupo_original},
        "descripcion": {"stringValue": producto.get("descripcion", "")},
        "imagen": {"stringValue": producto["imagen"]},
        "orden": {"integerValue": orden},
        "talles": {
            "arrayValue": {
                "values": [{"stringValue": t} for t in producto.get("talles", [])]
            }
        }
      }
 
    }

    try:
        response = requests.patch(url, headers=headers, data=json.dumps(data), timeout=5)
        print(f"üìÑ Firestore response: {response.status_code} ‚Üí {response.text}")
        return response.status_code in [200, 202]
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Error de red al subir {producto['nombre']}: {e}")
        return False

UPLOAD_FOLDER = 'static/img'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

# ‚úÖ Compresi√≥n y redimensionado
def redimensionar_con_transparencia(imagen, destino, tama√±o=(300, 180), calidad=80):
    try:
        img = Image.open(imagen.stream).convert('RGBA')
        img.thumbnail(tama√±o, Image.LANCZOS)

        fondo = Image.new('RGBA', tama√±o, (0, 0, 0, 0))  # fondo transparente
        offset = ((tama√±o[0] - img.width) // 2, (tama√±o[1] - img.height) // 2)
        fondo.paste(img, offset, img)  # usa la imagen como m√°scara

        fondo.save(destino, format='WEBP', quality=calidad)
    except Exception as e:
        print(f"Error al redimensionar con transparencia: {e}")

def necesita_redimension(src, dst):
    return not os.path.exists(dst) or os.path.getmtime(src) > os.path.getmtime(dst)

def subir_archivo(repo, contenido_bytes, ruta_remota, token):
    url = f"https://api.github.com/repos/{GITHUB_USERNAME}/{repo}/contents/{ruta_remota}"
    headers = {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github+json"
    }
    data = {
        "message": f"Subida de {ruta_remota}",
        "content": base64.b64encode(contenido_bytes).decode("utf-8"),
        "branch": "main"
    }
    r = requests.put(url, headers=headers, json=data)
    if r.status_code != 201:
        print(f"‚ùå Error al subir {ruta_remota}: {r.status_code} ‚Üí {r.text}")
    else:
        print(f"‚úÖ Subido: {ruta_remota}")

    return r.status_code == 201
    
def generar_nombre_repo(email):
    base = email.replace("@", "_at_").replace(".", "_")
    fecha = time.strftime("%Y%m%d")
    return f"{base}_{fecha}"


def crear_repo_github(nombre_repo, token):
    if not token:
        print("‚ùå Token no cargado desde entorno")
        return {"error": "Token no disponible"}

    url = "https://api.github.com/user/repos"
    headers = {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github+json"
    }
    data = {
        "name": nombre_repo,
        "private": False,
        "auto_init": True,
        "description": "Repositorio generado autom√°ticamente desde step1"
    }

    try:
        response = requests.post(url, headers=headers, json=data, timeout=5)
        if response.status_code == 201:
            repo_url = response.json().get("html_url", "URL no disponible")
            print(f"‚úÖ Repositorio creado: {repo_url}")
            return {"url": repo_url}
        else:
            print(f"‚ö†Ô∏è Error {response.status_code}: {response.text}")
            return {"error": response.text}
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Error de red: {e}")
        return {"error": str(e)}


def redimensionar_webp_en_static():
    carpeta = 'static/img/webp'
    os.makedirs(carpeta, exist_ok=True)
    for nombre in os.listdir(carpeta):
        if nombre.endswith('.webp'):
            ruta = os.path.join(carpeta, nombre)
            try:
                img = Image.open(ruta).convert('RGBA')
                tama√±o = (300, 180)

                img.thumbnail(tama√±o, Image.LANCZOS)
                fondo = Image.new('RGBA', tama√±o, (0, 0, 0, 0))
                offset = ((tama√±o[0] - img.width) // 2, (tama√±o[1] - img.height) // 2)
                fondo.paste(img, offset, img)

                fondo.save(ruta, format='WEBP', quality=80)
                print(f"Redimensionado con transparencia: {nombre}")
            except Exception as e:
                print(f"Error al redimensionar {nombre}: {e}")


# ‚úÖ Limpia im√°genes subidas por el usuario si el flujo se abandona o despu√©s de descargar
def limpiar_imagenes_usuario():
    carpeta = 'static/img/uploads'
    os.makedirs(carpeta, exist_ok=True)
    for nombre in os.listdir(carpeta):
        ruta = os.path.join(carpeta, nombre)
        try:
            if os.path.isfile(ruta):
                os.remove(ruta)
                print(f"Imagen eliminada: {nombre}")
        except Exception as e:
            print(f"Error al eliminar {nombre}: {e}")

@app.route('/crear-admin', methods=['POST'])
def crear_admin():
    data = request.get_json(silent=True) or {}
    usuario = data.get('usuario')
    clave = data.get('clave')

    print("üì• Datos recibidos:", data)

    if not usuario or not clave:
        print("‚ùå Faltan datos: usuario o clave vac√≠os")
        return jsonify({'status': 'error', 'message': 'Faltan datos'}), 400

    try:
        url = f"https://firestore.googleapis.com/v1/projects/{FIREBASE_PROJECT_ID}/databases/(default)/documents/usuarios/{usuario}?key={FIREBASE_API_KEY}"
        payload = {
            "fields": {
                "clave_admin": { "stringValue": clave }
            }
        }

        r = requests.patch(url, headers={"Content-Type": "application/json"}, data=json.dumps(payload))
        print("üì° Firestore response:", r.status_code, r.text)

        if r.status_code in [200, 201]:
            print(f"‚úÖ Admin creado correctamente: {usuario}")
            return jsonify({'status': 'ok'})
        else:
            return jsonify({'status': 'error', 'message': r.text}), r.status_code

    except Exception as e:
        print("‚ùå Error al guardar en Firestore:", e)
        return jsonify({'status': 'error', 'message': str(e)}), 500

@app.route('/login-admin', methods=['POST'])
def login_admin():
    data = request.get_json(silent=True) or {}
    usuario = data.get('usuario')
    clave_ingresada = data.get('clave')

    print("üîê Intentando login:", usuario)
    print("üîê Clave ingresada:", clave_ingresada)

    if not usuario or not clave_ingresada:
        print("‚ùå Faltan datos para login")
        return jsonify({'status': 'error', 'message': 'Faltan datos'}), 400

    try:
        url = f"https://firestore.googleapis.com/v1/projects/{FIREBASE_PROJECT_ID}/databases/(default)/documents/usuarios/{usuario}?key={FIREBASE_API_KEY}"
        r = requests.get(url)
        doc = r.json()

        clave_guardada = doc.get("fields", {}).get("clave_admin", {}).get("stringValue")
        print("üîê Clave guardada en Firestore:", clave_guardada)

        if clave_guardada == clave_ingresada:
            session.permanent = True  # ‚úÖ Mantener sesi√≥n activa
            session['modo_admin'] = True
            session['email'] = usuario
            print("üß† session despu√©s del login:", dict(session))
            print("‚úÖ Login exitoso ‚Üí modo_admin activado")
            print("üß† session:", dict(session))
            return jsonify({'status': 'ok'})
        else:
            print("‚ùå Clave incorrecta")
            return jsonify({'status': 'error', 'message': 'Clave incorrecta'}), 403

    except Exception as e:
        print("‚ùå Error al validar login:", e)
        print("üß† session despu√©s del login:", dict(session))
        return jsonify({'status': 'error', 'message': str(e)}), 500

@app.route('/logout-admin')
def logout_admin():
    session.pop('modo_admin', None)
    print("üîì Sesi√≥n admin cerrada")
    return redirect('/preview')

@app.route("/crear-repo", methods=["POST"])
def crear_repo():
    token = os.getenv("GITHUB_TOKEN")
    if not token:
        return "‚ùå Token no cargado desde entorno", 500

    email = request.json.get("email", f"repo-{uuid.uuid4().hex[:6]}")
    session['email'] = email
    nombre_repo = generar_nombre_repo(email)
    session['repo_nombre'] = nombre_repo  # ‚úÖ ESTA L√çNEA ES CLAVE

    resultado = crear_repo_github(nombre_repo, token)
    if "url" in resultado:
        session['repo_creado'] = resultado["url"]

    return jsonify(resultado), 200 if "url" in resultado else 400


@app.route('/actualizar-precio', methods=['POST'])
def actualizar_precio():
    data = request.get_json()
    id_base = data.get("id")
    nuevo_precio = int(data.get("nuevoPrecio", 0))

    url = (
        f"https://firestore.googleapis.com/v1/projects/{FIREBASE_PROJECT_ID}"
        f"/databases/(default)/documents/{FIREBASE_COLLECTION}/{id_base}"
        f"?key={FIREBASE_API_KEY}&updateMask.fieldPaths=precio"
    )
    headers = {"Content-Type": "application/json"}
    payload = {
        "fields": {
            "precio": {"integerValue": nuevo_precio}
        }
    }

    try:
        r = requests.patch(url, headers=headers, data=json.dumps(payload))
        print("üí∞ Precio actualizado:", r.status_code)
        return jsonify({"status": "ok"}), r.status_code
    except Exception as e:
        print("‚ùå Error al actualizar precio:", e)
        return jsonify({"error": str(e)}), 500

@app.route('/actualizar-talles', methods=['POST'])
def actualizar_talles():
    data = request.get_json()
    id_base = data.get("id")
    nuevos_talles = data.get("talles", [])

    url = (
        f"https://firestore.googleapis.com/v1/projects/{FIREBASE_PROJECT_ID}"
        f"/databases/(default)/documents/{FIREBASE_COLLECTION}/{id_base}"
        f"?key={FIREBASE_API_KEY}&updateMask.fieldPaths=talles"
    )
    headers = {"Content-Type": "application/json"}
    payload = {
        "fields": {
            "talles": {
                "arrayValue": {
                    "values": [{"stringValue": t} for t in nuevos_talles] if nuevos_talles else []
                }
            }
        }
    }

    try:
        r = requests.patch(url, headers=headers, data=json.dumps(payload))
        print("üëü Talles actualizados:", r.status_code)
        return jsonify({"status": "ok"}), r.status_code
    except Exception as e:
        print("‚ùå Error al actualizar talles:", e)
        return jsonify({"error": str(e)}), 500

@app.route('/actualizar-firestore', methods=['POST'])
def actualizar_firestore():
    data = request.get_json(silent=True) or {}
    id_base = data.get('id')
    campos = {k: v for k, v in data.items() if k != 'id'}

    if not id_base or not campos:
        return jsonify({'status': 'error', 'message': 'Datos incompletos'}), 400

    url = (
        f"https://firestore.googleapis.com/v1/projects/{FIREBASE_PROJECT_ID}"
        f"/databases/(default)/documents/{FIREBASE_COLLECTION}/{id_base}"
        f"?key={FIREBASE_API_KEY}&updateMask.fieldPaths=" + ",".join(campos.keys())
    )

    payload = {
        "fields": {
            k: (
                {"stringValue": v} if isinstance(v, str)
                else {"integerValue": v} if isinstance(v, int)
                else {"arrayValue": {"values": [{"stringValue": t} for t in v]}} if isinstance(v, list)
                else {"stringValue": str(v)}
            )
            for k, v in campos.items()
        }
    }

    headers = {"Content-Type": "application/json"}
    try:
        r = requests.patch(url, headers=headers, data=json.dumps(payload))
        print("‚úÖ Firestore actualizado:", r.status_code)
        return jsonify({"status": "ok"}), r.status_code
    except Exception as e:
        print("‚ùå Error al actualizar Firestore:", e)
        return jsonify({"error": str(e)}), 500


@app.route('/', methods=['GET', 'POST'])
def step1():
    limpiar_imagenes_usuario()
    if request.method == 'POST':
        session['tipo_web'] = 'cat√°logo'
        session['facebook'] = request.form.get('facebook')
        session['whatsapp'] = request.form.get('whatsapp')
        session['instagram'] = request.form.get('instagram')
        session['sobre_mi'] = request.form.get('sobre_mi')
        session['ubicacion'] = request.form.get('ubicacion')
        session['link_mapa'] = request.form.get('link_mapa')
        session['fuente'] = request.form.get('fuente')

        mercado_pago = request.form.get('mercado_pago')
        if mercado_pago and mercado_pago.startswith("APP_USR-"):
          session['mercado_pago'] = mercado_pago.strip()
          print("Credencial MP:", session.get('mercado_pago'))

        logo = request.files.get('logo')
        if logo:
            filename = secure_filename(logo.filename)
            if filename:
                logo.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
                session['logo'] = filename
        else:
            session['logo'] = None

        return redirect('/estilo')
    return render_template('step1.html')

@app.route('/estilo', methods=['GET', 'POST'])
def step2():
    if request.method == 'POST':
        session['color'] = request.form.get('color')
        session['estilo'] = request.form.get('estilo')
        session['bordes'] = request.form.get('bordes')
        session['botones'] = request.form.get('botones')
        session['vista_imagenes'] = request.form.get('vista_imagenes')
        session['estilo_visual'] = request.form.get('estilo_visual')

        return redirect('/contenido')

    imagenes = os.listdir('static/img/webp')
    return render_template('step2.html', config=session, imagenes=imagenes)

# ... encabezado y configuraciones previas ...

@app.route('/contenido', methods=['GET', 'POST'])
def step3():
    tipo = session.get('tipo_web')
    if request.method == 'POST':
        bloques = []
        nombres = request.form.getlist('nombre')
        descripciones = request.form.getlist('descripcion')
        precios = request.form.getlist('precio')
        grupos = request.form.getlist('grupo')
        subgrupos = request.form.getlist('subgrupo')  # ‚úÖ nuevo campo
        imagenes = request.files.getlist('imagen')
        ordenes = request.form.getlist('orden')
        talles = request.form.getlist('talles')


        longitudes = [len(nombres), len(precios), len(descripciones), len(grupos), len(subgrupos), len(imagenes), len(ordenes)]
        min_len = min(longitudes)
        print("üß™ Longitudes:", longitudes)

        if not all(l == min_len for l in longitudes):
            print("‚ùå Desalineaci√≥n en los datos del formulario")
            return "Error: los campos del formulario est√°n desalineados", 500

        MAX_SIZE_MB = 4
        formatos_validos = ('.jpg', '.jpeg', '.png', '.webp')

        for i in range(len(nombres)):
            nombre = nombres[i].strip()
            precio = precios[i].strip()
            grupo = grupos[i].strip() or 'Sin grupo'
            subgrupo = subgrupos[i].strip() or 'Sin subgrupo'
            orden = str(i + 1)
            img = imagenes[i]
            filename = secure_filename(img.filename)
            talle_raw = talles[i].strip() if i < len(talles) else ''
            talle_lista = [t.strip() for t in talle_raw.split(',') if t.strip()]


            if not nombre or not precio or not grupo or not subgrupo or not filename:
                continue

            if not filename.lower().endswith(formatos_validos):
                print(f"‚ö†Ô∏è Formato no soportado: {filename}")
                continue

            if img.content_length and img.content_length > MAX_SIZE_MB * 1024 * 1024:
                print(f"‚ö†Ô∏è Imagen demasiado pesada: {filename}")
                continue

            webp_name = f"{os.path.splitext(filename)[0]}_{shortuuid.uuid()[:4]}.webp"
            destino = os.path.join(app.config['UPLOAD_FOLDER'], webp_name)

            try:
                img.save(destino)
            except Exception as e:
                print(f"‚ùå Error al guardar imagen {filename}: {e}")
                continue

            bloques.append({
                'nombre': nombre,
                'descripcion': descripciones[i],
                'precio': precio,
                'imagen': webp_name,
                'grupo': grupo,
                'subgrupo': subgrupo,  # ‚úÖ incluir subgrupo
                'orden': ordenes[i],
                'talles': talle_lista
            })

        session['bloques'] = bloques
        exitos = 0
        fallos = 0

        def subir_con_resultado(producto):
            try:
                if subir_a_firestore(producto):
                    print(f"‚úÖ Producto subido: {producto['nombre']}")
                    return True
                else:
                    print(f"‚ö†Ô∏è Fallo al subir {producto['nombre']}")
                    return False
            except Exception as e:
                print(f"‚ùå Error inesperado al subir {producto['nombre']}: {e}")
                return False

        bloques_por_lote = 10
        try:
            for inicio in range(0, len(bloques), bloques_por_lote):
                lote = bloques[inicio:inicio + bloques_por_lote]
                with ThreadPoolExecutor(max_workers=5) as executor:
                    resultados = list(executor.map(subir_con_resultado, lote))
                    exitos += sum(resultados)
                    fallos += len(resultados) - sum(resultados)
        except Exception as lote_error:
            print(f"üî• Error cr√≠tico en lote de subida: {lote_error}")

        print(f"üßÆ Subidos correctamente: {exitos} / Fallidos: {fallos}")

        if exitos > 0:
            return redirect('/preview')
        else:
            return render_template('step3.html', tipo_web=tipo)

    return render_template('step3.html', tipo_web=tipo)
import mercadopago

@app.route('/pagar', methods=['POST'])
def pagar():
    try:
        data = request.get_json(silent=True) or {}
        carrito = data.get('carrito', [])
        access_token = session.get('mercado_pago')

        if not access_token:
            return jsonify({'error': 'Credencial de Mercado Pago no configurada'}), 400

        sdk = mercadopago.SDK(access_token)

        items = []
        for item in carrito:
            items.append({
                "title": item['nombre'] + (f" ({item['talle']})" if item.get('talle') else ""),
                "quantity": item['cantidad'],
                "unit_price": float(item.get('precio', 0)),
                "currency_id": "ARS"
            })

        preference_data = {
            "items": items,
            "back_urls": {
                "success": url_for('preview', _external=True),
                "failure": url_for('preview', _external=True),
                "pending": url_for('preview', _external=True)
            },
            "auto_return": "approved",
            "statement_descriptor": "TuEmprendimiento",
            "external_reference": "pedido_" + datetime.now().strftime("%Y%m%d%H%M%S")
        }

        preference_response = sdk.preference().create(preference_data)
        preference = preference_response["response"]

        return jsonify({"init_point": preference["init_point"]})
    
    except Exception as e:
        import traceback
        print("‚ö†Ô∏è Error en /pagar:", e)
        traceback.print_exc()  # ‚úÖ muestra el traceback completo en los logs
        return jsonify({'error': 'Error interno al generar el pago'}), 500

    return jsonify({"init_point": preference["init_point"]})

@app.route('/preview')
def preview():
    print("üöÄ Entrando a /preview")
    modo_admin = session.get('modo_admin') == True and request.args.get('admin') == 'true'
    modo_admin_intentado = request.args.get('admin') == 'true'
    print("üîç repo_creado:", session.get('repo_creado'))
    print("üîç repo_nombre:", session.get('repo_nombre'))
    
    estilo_visual = session.get('estilo_visual') or 'claro_moderno'

    config = {
        'titulo': session.get('titulo'),
        'descripcion': session.get('descripcion'),
        'imagen_destacada': session.get('imagen_destacada'),
        'url': session.get('url'),
        'nombre_emprendimiento': session.get('nombre_emprendimiento'),
        'anio': session.get('anio'),
        'tipo_web': session.get('tipo_web'),
        'ubicacion': session.get('ubicacion'),
        'link_mapa': session.get('link_mapa'),
        'color': session.get('color'),
        'fuente': session.get('fuente'),
        'estilo': session.get('estilo'),
        'bordes': session.get('bordes'),
        'botones': session.get('botones'),
        'vista_imagenes': session.get('vista_imagenes'),
        'logo': session.get('logo'),
        'estilo_visual': estilo_visual,
        'facebook': session.get('facebook'),
        'whatsapp': session.get('whatsapp'),
        'instagram': session.get('instagram'),
        'sobre_mi': session.get('sobre_mi'),
        'mercado_pago': session.get('mercado_pago'),
        'productos': session.get('bloques') if session.get('tipo_web') == 'cat√°logo' else [],
        'bloques': [],
        'descargado': session.get('descargado', False),
        'usarFirestore': True
    }

    for i, p in enumerate(config['productos']):
        p['id_base'] = p['nombre'].replace(' ', '_') + f"_{i}"

    grupos_dict = {}
    for producto in config['productos']:
        grupo = producto.get('grupo') or producto.get('Grupo') or 'General'
        subgrupo = producto.get('subgrupo') or producto.get('subGrupo') or 'Sin subgrupo'

        grupo = grupo.strip().title()
        subgrupo = subgrupo.strip().title()

        if grupo not in grupos_dict:
            grupos_dict[grupo] = {}
        if subgrupo not in grupos_dict[grupo]:
            grupos_dict[grupo][subgrupo] = []
        grupos_dict[grupo][subgrupo].append(producto)

    # ‚úÖ Crear repo si no existe
    if not session.get('repo_creado'):
        email = session.get('email') or "sin_email@appweb.com"
        nombre_repo = generar_nombre_repo(email)
        print("üì¶ Intentando crear repo con:", nombre_repo)
        token = os.getenv("GITHUB_TOKEN")
        resultado = crear_repo_github(nombre_repo, token)
        print("üì¶ Resultado:", resultado)
        if "url" in resultado:
            session['repo_creado'] = resultado["url"]
            session['repo_nombre'] = nombre_repo
        else:
            print("‚ö†Ô∏è No se pudo crear el repositorio:", resultado.get("error"))

    # ‚úÖ Subir archivos si el repo existe
    if session.get('repo_creado') and session.get('repo_nombre'):
        nombre_repo = session['repo_nombre']
        token = os.getenv("GITHUB_TOKEN")
        print("üì§ Subiendo archivos al repo:", nombre_repo)

        # Subir index.html
        template = current_app.jinja_env.get_template('preview.html')
        html = template.render(config=config, grupos=grupos_dict, modoAdmin=modo_admin, modoAdminIntentado=modo_admin_intentado)
        subir_archivo(nombre_repo, html.encode("utf-8"), "index.html", token)
        print("üìÑ Subido: index.html")

        # Subir im√°genes
        for producto in config['productos']:
            imagen = producto.get("imagen")
            if imagen:
                ruta_local = os.path.join(app.config['UPLOAD_FOLDER'], imagen)
                if os.path.exists(ruta_local):
                    with open(ruta_local, "rb") as f:
                        contenido = f.read()
                    subir_archivo(nombre_repo, contenido, f"static/img/{imagen}", token)
                    print(f"üñºÔ∏è Subida imagen: {imagen}")
                else:
                    print(f"‚ö†Ô∏è Imagen no encontrada: {imagen}")

        # Subir logo
        logo = config.get("logo")
        if logo:
            logo_path = os.path.join(app.config['UPLOAD_FOLDER'], logo)
            if os.path.exists(logo_path):
                with open(logo_path, "rb") as f:
                    contenido = f.read()
                subir_archivo(nombre_repo, contenido, f"static/img/{logo}", token)
                print(f"üéØ Subido logo: {logo}")
            else:
                print(f"‚ö†Ô∏è Logo no encontrado: {logo}")

        # Subir fondo visual
        fondo = f"{estilo_visual}.jpeg"
        fondo_path = os.path.join(app.config['UPLOAD_FOLDER'], fondo)
        if os.path.exists(fondo_path):
            with open(fondo_path, "rb") as f:
                contenido = f.read()
            subir_archivo(nombre_repo, contenido, f"static/img/{fondo}", token)
            print(f"üåÑ Subido fondo visual: {fondo}")
        else:
            print(f"‚ö†Ô∏è Fondo visual no encontrado: {fondo}")

    print("üß† session['modo_admin']:", session.get('modo_admin'))
    print("üß† modo_admin:", modo_admin)
    print("üß† modo_admin_intentado:", modo_admin_intentado)
    print("üß† session completa:", dict(session))

    return render_template('preview.html', config=config, grupos=grupos_dict, modoAdmin=modo_admin, modoAdminIntentado=modo_admin_intentado)

@app.route('/descargar')
def descargar():
    estilo_visual = session.get('estilo_visual') or 'claro_moderno'

    config = {
        'tipo_web': session.get('tipo_web'),
        'ubicacion': session.get('ubicacion'),
        'link_mapa': session.get('link_mapa'),
        'color': session.get('color'),
        'fuente': session.get('fuente'),
        'estilo': session.get('estilo'),
        'bordes': session.get('bordes'),
        'botones': session.get('botones'),
        'vista_imagenes': session.get('vista_imagenes'),
        'logo': session.get('logo'),
        'estilo_visual': estilo_visual,
        'facebook': session.get('facebook'),
        'whatsapp': session.get('whatsapp'),
        'instagram': session.get('instagram'),
        'sobre_mi': session.get('sobre_mi'),
        'productos': session.get('bloques') if session.get('tipo_web') == 'cat√°logo' else [],
        'bloques': []
    }

    # ‚úÖ Construir grupos y subgrupos con validaci√≥n y normalizaci√≥n
    grupos = {}
    for producto in config['productos']:
        grupo = producto.get('grupo') or producto.get('Grupo') or 'General'
        subgrupo = producto.get('subgrupo') or producto.get('subGrupo') or 'Sin subgrupo'

        grupo = grupo.strip().title()
        subgrupo = subgrupo.strip().title()

        if grupo not in grupos:
            grupos[grupo] = {}
        if subgrupo not in grupos[grupo]:
            grupos[grupo][subgrupo] = []
        grupos[grupo][subgrupo].append(producto)

    # ‚úÖ Renderizar HTML con grupos incluidos
    html = render_template('preview.html', config=config, grupos=grupos)

    # ‚úÖ Crear ZIP con HTML y recursos
    zip_buffer = BytesIO()
    with ZipFile(zip_buffer, 'w') as zip_file:
        zip_file.writestr('index.html', html)

        # ‚úÖ Incluir fondo visual
        fondo = f"{estilo_visual}.jpeg"
        fondo_path = os.path.join(app.config['UPLOAD_FOLDER'], fondo)
        if os.path.exists(fondo_path):
            zip_file.write(fondo_path, arcname='img/' + fondo)

        # ‚úÖ Incluir im√°genes de productos
        for producto in config['productos']:
            imagen = producto.get('imagen')
            if imagen:
                imagen_path = os.path.join(app.config['UPLOAD_FOLDER'], imagen)
                if os.path.exists(imagen_path):
                    zip_file.write(imagen_path, arcname='img/' + imagen)

    limpiar_imagenes_usuario()
    session['descargado'] = True

    zip_buffer.seek(0)
    return send_file(zip_buffer, mimetype='application/zip', as_attachment=True, download_name='sitio.zip')

@app.template_filter('imgver')
def imgver_filter(name):
    try:
        return int(os.path.getmtime(os.path.join(app.config['UPLOAD_FOLDER'], name))) % 10_000
    except Exception:
        return 0
        
@app.after_request
def cache(response):
    if request.path.startswith("/static/img"):
        response.headers["Cache-Control"] = "public, max-age=31536000"
    return response

if __name__ == '__main__':
    redimensionar_webp_en_static()
    limpiar_imagenes_usuario()
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=True)
